{"meta":{"title":"易网盟","subtitle":"专注网站建设优化，做互联网的搬砖人","description":"Hexo/Hugo... + GitHub 免费仓库托管入门教程引导。用最简单的方案，办最实用的事，微软不倒，羊毛到老！","author":"test2","url":"https://Junxiansen.cn","root":"/"},"pages":[{"title":"archives","date":"2020-07-18T05:10:34.000Z","updated":"2023-03-29T14:34:31.667Z","comments":true,"path":"archives/index.html","permalink":"https://junxiansen.cn/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-30T03:41:17.000Z","updated":"2023-03-29T14:34:31.667Z","comments":true,"path":"categories/index.html","permalink":"https://junxiansen.cn/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-30T14:45:09.000Z","updated":"2023-03-29T14:34:31.667Z","comments":true,"path":"contact/index.html","permalink":"https://junxiansen.cn/contact/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-31T10:09:56.000Z","updated":"2016-12-31T10:09:56.000Z","comments":false,"path":"history/index.html","permalink":"https://junxiansen.cn/history/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-30T14:40:51.000Z","updated":"2023-03-29T14:34:31.668Z","comments":true,"path":"friends/index.html","permalink":"https://junxiansen.cn/friends/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2023-03-29T14:34:31.666Z","updated":"2023-03-29T14:34:31.666Z","comments":true,"path":"about/index.html","permalink":"https://junxiansen.cn/about/index.html","excerpt":"","text":"这是个互联网爱好者个人小站，完全出于兴趣爱好自封互联网研究院院长，乐于分享计算机相关使用方法，推广优质实用软件。所有技术类文章除特别说明外均为本站原创，所提供的软件为院长原创或由网络整理而来。 本院始终坚信： 分享是种美德，好人一生平安！ 本着尊重国家法律的精神，根据中华人民共和国国务院令第632号规定： 第十七条 为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。 本站所有资源均为学习，交流使用，不得用于任何商业用途。使用的软件请下载后24小时内自行删除，若由于研究学习本站提供文件或链接下载的软件而带来损失，本站不负任何责任。 如果您发现本站侵害了您的版权，请联系院长并出示版权证明，院长将第一时间进行相关处理。 如果您也一样热爱互联网，喜欢捣鼓软件，欢迎评论留言或与院长联系。 QQ群：键盘侠 260489333，点此加群"},{"title":"友链","date":"2022-05-28T03:09:14.000Z","updated":"2023-03-29T14:34:31.669Z","comments":true,"path":"link/index.html","permalink":"https://junxiansen.cn/link/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-24T09:37:05.000Z","updated":"2017-02-24T09:37:05.000Z","comments":true,"path":"tags/index.html","permalink":"https://junxiansen.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2099-09-09T01:09:09.000Z","updated":"2023-03-29T14:34:31.666Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://junxiansen.cn/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Academia本页之所以会作为 Academia 主题首页内容，是因为 Front-Matter 中添加了主题所要求的 academia: true 标识，该主题设置使用方法敬请查看 Academia 主题对应文档，或者参考 此示例 。","categories":[],"tags":[{"name":"Example","slug":"Example","permalink":"https://junxiansen.cn/tags/Example/"}]},{"title":"3-时钟节拍","slug":"3-时钟节拍","date":"2022-08-28T15:04:31.000Z","updated":"2022-08-28T15:04:57.339Z","comments":true,"path":"3-时钟节拍.html","link":"","permalink":"https://junxiansen.cn/3-%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D.html","excerpt":"","text":"","categories":[{"name":"uCOS-III","slug":"uCOS-III","permalink":"https://junxiansen.cn/categories/uCOS-III/"}],"tags":[{"name":"时钟节拍","slug":"时钟节拍","permalink":"https://junxiansen.cn/tags/%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D/"}]},{"title":"2-创建LED灯任务","slug":"2-创建LED灯任务","date":"2022-08-28T13:07:16.000Z","updated":"2022-08-28T15:02:26.861Z","comments":true,"path":"2-创建LED灯任务.html","link":"","permalink":"https://junxiansen.cn/2-%E5%88%9B%E5%BB%BALED%E7%81%AF%E4%BB%BB%E5%8A%A1.html","excerpt":"","text":"创建LED灯的任务首先要了解创建任务函数代码OSTaskCreate(),其函数在ucos-iii的api手册中有描述。该描述说通过提供的参数指定任务将如何被管理。任务始终在准备运行状态下创建，也就是OS_Init()函数之后。 OS_TCB *p_tcb是结构体类型的指针，存储任务的配置信息，定义为全局变量。 CPU_CHAR *p_name是一个ASCII码的字符串指针，给任务分配一个名字，用来调试时显示。 OS_TASK_PTR p_task是一个任务的指针，填写任务的函数名。其实任务作为一个死循环，任务就是一个函数。 void *p_arg是传递任务参数 OS_PRIO prio是任务的优先级，数值越低任务优先级越高，但是优先级0和优先级1，优先级62和优先级63是保留的需要将优先级设置从2开始。 CPU_STK *p_stk_base任务栈空间基地址的指针，任务的栈用来存储局部的变量，函数的参数，返回地址，以及中断过程中保存cpu寄存器的信息。 CPU_STK_SIZE stk_limit是任务堆栈的限制，监视确保任务的堆栈没有溢出。 CPU_STK_SIZE stk_size是当前任务栈空间的大小。 OS_MSG_QTY q_size是任务内部消息队列。如果参数设置为0，用户无法收到消息。 OS_TICK time_quanta时间片轮转的时间，如果是0将使用默认的时间片。 void *p_ext是任务控制块的扩展信息，绝大部分该参数并不会使用到。 OS_OPT opt是任务相关的选项。 OS_ERR *p_err用来存放错误代码的指针。 创建一个My_FirstTask任务代码可以写成： 需要定义全局变量任务控制块的大小OS_TCB My_TaskTcb; 任务堆栈的大小CPU_STK My_FirstTaskSTK[128]; 1234567891011121314//CreateTaskOSTaskCreate ((OS_TCB *)&amp;My_TaskTcb, (CPU_CHAR *)&quot;My first task&quot;, (OS_TASK_PTR)My_FirstTask, (void *)0, (OS_PRIO )2, (CPU_STK *)&amp;My_FirstTaskSTK[0], (CPU_STK_SIZE)12, (CPU_STK_SIZE)128, (OS_MSG_QTY )0u, (OS_TICK )0u, (void *)0, (OS_OPT )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR), (OS_ERR *)&amp;err); 此时需要定义My_FirstTask任务，一个任务的基本结构代码：(void)p_arg;防止编译器报警，因为定义的形参p_arg没有使用到。 12345678910void My_FirstTask(void *p_arg)&#123; (void)p_arg; while(1) &#123; &#125;&#125; 下面开始主题，创建LED任务，点亮两个led灯。 首先初始化Led的GPIO引脚，这里就不过多描述了。 123456789101112void Led_Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#125; 在main.c中： 1234567891011121314151617181920212223242526272829303132#include &quot;includes.h&quot;#include &quot;led.h&quot;OS_TCB LedTask_TCB;CPU_STK LedTask_Stk[128];int main(void)&#123; OS_ERR err; Led_Config(); /* 初始化&quot;uC/OS-III&quot;内核 */ OSInit(&amp;err); //CreateTask OSTaskCreate((OS_TCB *)&amp;LedTask_TCB, (CPU_CHAR *)&quot;Led_Task&quot;, (OS_TASK_PTR)Led_Task, (void *)0, (OS_PRIO )2, (CPU_STK *)&amp;LedTask_Stk[0], (CPU_STK_SIZE)12, (CPU_STK_SIZE)128, (OS_MSG_QTY )0u, (OS_TICK )0u, (void *)0, (OS_OPT )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR), (OS_ERR *)&amp;err); /* 启动多任务系统，控制权交给uC/OS-III */ OSStart(&amp;err); &#125; 在Led_Task函数中 12345678910111213141516void Led_Task(void *p_arg)&#123; (void)p_arg; while(1) &#123; Led1_ON; Led2_ON; Delay(10000000); Led1_OFF; Led2_OFF; Delay(10000000); &#125;&#125;","categories":[{"name":"uCOS-III","slug":"uCOS-III","permalink":"https://junxiansen.cn/categories/uCOS-III/"}],"tags":[{"name":"创建任务","slug":"创建任务","permalink":"https://junxiansen.cn/tags/%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1/"}]},{"title":"1-2栈的应用_逆波兰表示法","slug":"1-2栈的应用-逆波兰表示法","date":"2022-08-26T07:29:29.000Z","updated":"2022-08-26T07:38:53.747Z","comments":true,"path":"1-2栈的应用-逆波兰表示法.html","link":"","permalink":"https://junxiansen.cn/1-2%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95.html","excerpt":"","text":"1栈的应用，逆波兰算法(后缀算法)1、逆波兰表示法：为什么要将看似简单的中序表达式转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构 本次逆波兰表示法只考虑个位数，不考虑十位数的。运算只考虑加减乘，不考虑除法和取余。 中缀表示法(1+2)*(3-4) 逆波兰表示法12+34-* 其思想就是操作运算符放在后面 第一步(1+2)(3-4)* 第二步12+34-* 再比如5x（（（9+8）x（4x6））+7） 第一步5（（（9+8）x（4x6））+7）x 第二步5（（9+8）x（4x6））7+x 第三步5（9+8）（4x6）x7+x 第四步598+46xx7+x 其思想就是数字按顺序入栈，遇到运算符出栈。然后将出栈的数字进行运算，运算结果存入栈里。 12+34-*图解为，最后结果为-3与中缀表示法得数相同 598+46xx7+x，结果为2075 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;int stack[518];int top = 0;void push(int c);int pop(void);int is_Empty(void);int main(void)&#123; char a[100]; int i,n; gets(a); n = strlen(a); for(i=0;i&lt;n;i++) &#123; if((a[i]&lt;=&#x27;9&#x27;)&amp;&amp;(a[i]&gt;=&#x27;0&#x27;)) &#123; push(a[i]-&#x27;0&#x27;);//字符串转换成整型。字符转化为数字的时候经常要用到，比如要将‘8’转换为数字8，在语句中这样写就可以了，“ 8+‘0’ ” &#125; else &#123; int n1 = pop(); int n2 = pop(); switch(a[i]) &#123; case &#x27;+&#x27;: push(n2+n1); break; case &#x27;-&#x27;: push(n2-n1); break; case &#x27;*&#x27;: push(n2*n1); break; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,pop()); return 0;&#125;//入栈void push(int c)&#123; stack[top++] = c;&#125;//出栈int pop(void)&#123; return stack[--top];&#125;//检测栈是否为空int is_Empty(void)&#123; return top == 0;&#125; 思考：如何将中位表达式转化成逆波兰表达式？","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://junxiansen.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://junxiansen.cn/tags/%E6%A0%88/"}]},{"title":"1-1栈实现原理","slug":"1-1栈实现原理","date":"2022-08-26T07:28:42.000Z","updated":"2022-08-26T08:20:28.208Z","comments":true,"path":"1-1栈实现原理.html","link":"","permalink":"https://junxiansen.cn/1-1%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html","excerpt":"","text":"栈实现原理 数组+循环 就可以实现栈和队列 什么是栈？FILO （First Input Last Out） 例如子弹装到弹夹里，最先放到的子弹，最后射出。同样的最后放的子弹，最先射出。 栈里面的内容可以是任意数据类型，数组可以是整型，浮点型，字符型，结构体数组。 存储数据叫入栈，取出数据叫出栈。 栈和数组的区别：数组可以访问任何元素，栈只能每次访问栈的最顶端。 栈的操作有：入栈，出栈，判断栈是否为空 栈需要指针来操作，指针永远指向栈顶空白的空间，出栈操作，指针向下挪一个位置 栈顶指针其实是数组空的元素编号。 入栈，出栈，检测栈是否为空代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;char stack[518];int top = 0;void push(char c);char pop(void);int is_Empty(void);int main(void)&#123; push(&#x27;a&#x27;); push(&#x27;b&#x27;); push(&#x27;c&#x27;); while(!is_Empty()) &#123; putchar(pop()); &#125; printf(&quot;\\n&quot;); return 0;&#125;void push(char c)&#123; stack[top++] = c;&#125;char pop(void)&#123; return stack[--top];&#125;int is_Empty(void)&#123; return top == 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://junxiansen.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈的原理","slug":"栈的原理","permalink":"https://junxiansen.cn/tags/%E6%A0%88%E7%9A%84%E5%8E%9F%E7%90%86/"}]},{"title":"数据结构背景","slug":"数据结构背景","date":"2022-08-26T07:27:48.000Z","updated":"2022-08-26T08:16:21.767Z","comments":true,"path":"数据结构背景.html","link":"","permalink":"https://junxiansen.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%83%8C%E6%99%AF.html","excerpt":"","text":"数据结构+算法 &#x3D; 程序 算法是计算机处理问题的步骤，步骤一定是代码可实现的， 数据结构：作为处理对象数据的排列方式， 实际上真正提高编程水平，算法为内功（数学是基础思想） 数据结构是算法的基础，所以要先学习数据结构， 数据才是程序中心，找到数据最佳的组织方式，算法才能事半功倍。 数据结构就是组织数据最有效的排列方式 算法决定程序的优劣，在解决同一个问题时，用不同算法（思想）得出结果千差万别。 在数据规模庞大时候，算法决定程序的生死，例如排序问题，有100w个数，用冒泡和快速算法，冒泡要很久，快速相对好一点。算法选的不好没有实际意义。 算法关键在于思想和设计巧妙，语法规则不重要 一个高级程序员工程师具备：数据机构+算法+数学思想+流程思想+逻辑思想 数据结构： 1、基础数据结构 2、图 3、排序 4、查找 5、高级数据结构 算法： 贪心算法、分制法、动态规划、回溯法。 做例题and面试题，刷Leetcode","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://junxiansen.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"背景","slug":"背景","permalink":"https://junxiansen.cn/tags/%E8%83%8C%E6%99%AF/"}]},{"title":"1-uCOS-III的使用与基本配置","slug":"1-uCOS-III的使用与基本配置","date":"2022-08-24T03:31:27.000Z","updated":"2022-08-24T05:13:14.043Z","comments":true,"path":"1-uCOS-III的使用与基本配置.html","link":"","permalink":"https://junxiansen.cn/1-uCOS-III%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"uCOS-III的基本配置与使用 uC_Source目录下是uCOSIII的&#x3D;&#x3D;源代码&#x3D;&#x3D;，此列表下的文件与任何CPU都无关，若移植其他芯片时该文件中的源码不需要更改。调用api时基本使用的是该目录下的文件。 uC_Cfg 目录包含整个工程的&#x3D;&#x3D;配置文件&#x3D;&#x3D;，配置系统功能的使能，系统运行的状况，环境配置选项有关的。 uC_Lib库目录包含有常见的ascii码，数学math，内存mem，字符串str源代码，在使用的过程中有&#x3D;&#x3D;数据的处理，运算等&#x3D;&#x3D;。 uC_Ports接口目录，该目录下的文件与&#x3D;&#x3D;移植系统&#x3D;&#x3D;有关，不同的处理器，把一些硬件的特性和语言控制的接口与uCOS-III结合起来。 uC_CPU目录包含&#x3D;&#x3D;cpu&#x3D;&#x3D;相关的代码，因为不同处理器使用cpu不同，移植的时候也会修改部分代码。 uCOS应该如何使用，在main函数中一定有这3步，第一步使用&#x3D;&#x3D;OSInit（）&#x3D;&#x3D;来初始化uCOS系统的内核，第二步&#x3D;&#x3D;创建任务&#x3D;&#x3D;，第三步使用&#x3D;&#x3D;OSStart（）&#x3D;&#x3D;来启动操作系统 OSInit（）函数中有两个任务是一定被创建中的一个是空闲任务&#x3D;&#x3D;OS_IdleTask()&#x3D;&#x3D;，另一个是时钟基准的任务&#x3D;&#x3D;OS_TickTask()&#x3D;&#x3D;。有三个任务是根据条件创建的，要打开对应的宏，软件定时器任务OS_TmrTask()，中断队列任务OS_IntQTask()，统计信息任务OS_StatTask()。 uCOS任务一共有5种状态，&#x3D;&#x3D;休眠态，就绪态，运行态，等待态，中断服务态&#x3D;&#x3D;，任何任务都是这5种状态之一。 通过&#x3D;&#x3D;调用特定的函数，任务的状态可以相互转换&#x3D;&#x3D;。","categories":[{"name":"uCOS-III","slug":"uCOS-III","permalink":"https://junxiansen.cn/categories/uCOS-III/"}],"tags":[{"name":"uCOS","slug":"uCOS","permalink":"https://junxiansen.cn/tags/uCOS/"}]},{"title":"Windows字符集","slug":"Windows字符集","date":"2022-08-23T08:10:46.000Z","updated":"2022-08-23T08:11:49.684Z","comments":true,"path":"Windows字符集.html","link":"","permalink":"https://junxiansen.cn/Windows%E5%AD%97%E7%AC%A6%E9%9B%86.html","excerpt":"","text":"Windows字符集 老外使用多字节，1个字符对应1个字节。 中文使用宽字节，Unicode（宽字节）,1个字符对应多个字节。例如utf-8，1个字符对应3个字节。GBK1个字符对应2个字节。 多字节转为宽字节，前面加L 1MessageBox(L&quot;aaa&quot;); 使用TEXT，可以自适应编码转换 1MessageBox(TEXT(&quot;aaa&quot;)); 统计多字节字符串长度 12345int len = 0;char *p = &quot;aaa&quot;;num = strlen(p); 统计宽字节字符串长度 12345int len =0;wchar_t *p = L&quot;aaa&quot;;len = wcslen(p); char * 与 CString 之间转换– char *转CString 123char * p =&quot;aaa&quot;CString str = CString(p); ​ – CString 转 char * 1234567CString str;CStringA tmp;tmp = str;char * p =tmp.GetBuffer(); 若使用C++的string转成MFC的CString，需要中间桥梁char *p，先将string转成char *p再转CString，或者CString 转成 char * p再转string。","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"字符集","slug":"字符集","permalink":"https://junxiansen.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"}]},{"title":"4-MFC基于对话框学习控件(3)","slug":"4-MFC基于对话框学习控件-3","date":"2022-08-23T08:02:33.000Z","updated":"2022-08-23T08:16:25.259Z","comments":true,"path":"4-MFC基于对话框学习控件-3.html","link":"","permalink":"https://junxiansen.cn/4-MFC%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%AD%A6%E4%B9%A0%E6%8E%A7%E4%BB%B6-3.html","excerpt":"","text":"下拉框控件使用 下拉框控件名称为Combo Box，属性中添加数据通过分号隔开，默认情况下Combo Box类型是可以编辑的，需要设置为DropList（下拉列表）不可编辑。 如果行为栏中Sort（排序选项），True时会将数据从字符A-Z排序，False时会根据你填写的数据来排序，一般选择False。 添加数据使用AddString()函数 12//添加下拉选项m_cbx.AddString(TEXT(&quot;唐僧&quot;)); 插入数据使用InserString()函数 12//插入下拉选项m_cbx.InsertString(4, TEXT(&quot;白龙马&quot;)); 删除数据使用DeleteString()函数 12//删除下拉选项m_cbx.DeleteString(3); 设置默认选项使用SetCurSel()函数，大致意思为Set Current Select 12//设置默认选项m_cbx.SetCurSel(0); 添加OnCbnSelchangeCombo选择变化的控件事件，其中GetCurSel()函数可以获取当前的索引，返回一个int型整数，getLBText(int index, CString str)函数根据索引值获取内容。 12345678void CcomboBoxContrlDlg::OnCbnSelchangeCombo2()&#123; // TODO: 在此添加控件通知处理程序代码 int index = m_cbx.GetCurSel(); CString str; m_cbx.GetLBText(index,str); MessageBox(str);&#125; 列表控件的使用 列表控件名称为List Control，属性中在View(视图)选择report模式（报表模式）。 添加表头函数为InsertColumn(),其中4个参数依次分别是：索引、内容、对齐方式、列宽度 123456CString str[] = &#123;TEXT(&quot;姓名&quot;),TEXT(&quot;性别&quot;),TEXT(&quot;年龄&quot;) &#125;;for (int i=0; i &lt; 3; i++) &#123; m_list.InsertColumn(i, str[i], LVCFMT_LEFT,100);&#125; 设置正文，从0开始索引，先插入一项，再设置该项的值。其中SetItemText(行，列，具体内容) 123//设置正文m_list.InsertItem(0, TEXT(&quot;张三&quot;));m_list.SetItemText(0, 1, TEXT(&quot;男&quot;)); 设置列表如图所示： 代码可以写为： 123456789101112int j;for (int i = 0; i &lt; 10; i++) &#123; j = 0; CString name; name.Format(TEXT(&quot;张三_%d&quot;), i); m_list.InsertItem(i, name); m_list.SetItemText(i, ++j, TEXT(&quot;男&quot;)); m_list.SetItemText(i, ++j, TEXT(&quot;23&quot;));&#125; 设置列表属性和整行选中状态，在列表背景下显示网格 1m_list.SetExtendedStyle(m_list.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES); 树控件的使用在属性栏中Has Lines（具有线）让树控件有线连接。Has Buttons（具有按钮）让树控件有按钮进行折叠，展开。 Lines At Root（行在根处）根节点与根节点有线连接。 1设置图标列表集合 SetImageList() CImageList list; 需要&#x3D;&#x3D;把图片集合变量添加到头文件&#x3D;&#x3D;定义为全局变量 2在资源视图ICON中添加资源，导入ICON图片文件 创建图片集合list.Create(cx,cy,nFlags,nInitial,nGrow) 添加具体的图片list.Add(HICON hicon),参数类型为ICON类型 创建HICON图标HICON icons[4] icon[0] &#x3D; AfxGetApp()-&gt;LoadIconW(nID),nID为图片的ID号 通过循环将4个图片添加到list里面 for(int i &#x3D;0;i&lt;4;i++) { ​ list.Add(icons[i]); } 将添加好的list写入SetImageList()参数中 设置节点使用InserItem()，该函数返回值是HTREEITEM 必须保存图片的集合，所以要定义CImageList list定义在.h文件中做成员的属性 12345678910111213141516171819202122// TODO: 在此添加额外的初始化代码HICON icons[4];icons[0] = AfxGetApp()-&gt;LoadIconW(IDI_ICON1);icons[1] = AfxGetApp()-&gt;LoadIconW(IDI_ICON2);icons[2] = AfxGetApp()-&gt;LoadIconW(IDI_ICON3);icons[3] = AfxGetApp()-&gt;LoadIconW(IDI_ICON4);list.Create(30, 30, ILC_COLOR32, 4, 4);for (int i =0;i&lt;4;i++) &#123; list.Add(icons[i]);&#125;m_tree.SetImageList(&amp;list, TVSIL_NORMAL);HTREEITEM root = m_tree.InsertItem(TEXT(&quot;根节点&quot;), 0, 0, NULL);HTREEITEM parent = m_tree.InsertItem(TEXT(&quot;父节点&quot;), 1, 1, root);HTREEITEM sub1 = m_tree.InsertItem(TEXT(&quot;子节点1&quot;), 2, 2, parent);HTREEITEM sub2 = m_tree.InsertItem(TEXT(&quot;子节点2&quot;), 3, 3, parent);m_tree.SelectItem(parent); 其他api介绍： 1）SelectItem(HTREEITEM I);默认选择一个节点。 2）节点与节点切换时需要TVN_SELCHANGED控件事件 ​ GetSelectedItem()返回一个HTREITEM类型变量 ​ GetItemText(HTREEITEM)参数类型为HTREEITEM，返回值时CString类型 选择变化的节点代码可以这么写： 12345678910void CTreeContrlDlg::OnTvnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult)&#123; LPNMTREEVIEW pNMTreeView = reinterpret_cast&lt;LPNMTREEVIEW&gt;(pNMHDR); // TODO: 在此添加控件通知处理程序代码 *pResult = 0; HTREEITEM item; item = m_tree.GetSelectedItem(); CString str = m_tree.GetItemText(item); MessageBox(str);&#125; 树控件学习运行如图： 标签页的使用标签页控件叫做Tab Control，首先在项目中引用TabSheet.cpp和TabSheet.h文件。 TabSheet.h代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#if !defined(AFX_TABSHEET_H__42EE262D_D15F_46D5_8F26_28FD049E99F4__INCLUDED_)#define AFX_TABSHEET_H__42EE262D_D15F_46D5_8F26_28FD049E99F4__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000// TabSheet.h : header file///////////////////////////////////////////////////////////////////////////////// CTabSheet window#define MAXPAGE 16class CTabSheet : public CTabCtrl&#123; // Constructionpublic: CTabSheet(); // Attributespublic: // Operationspublic: // Overrides // ClassWizard generated virtual function overrides //&#123;&#123;AFX_VIRTUAL(CTabSheet) //&#125;&#125;AFX_VIRTUAL // Implementationpublic: int GetCurSel(); int SetCurSel(int nItem); void Show(); void SetRect(); BOOL AddPage(LPCTSTR title, CDialog *pDialog, UINT ID); virtual ~CTabSheet(); // Generated message map functionsprotected: LPCTSTR m_Title[MAXPAGE]; UINT m_IDD[MAXPAGE]; CDialog* m_pPages[MAXPAGE]; int m_nNumOfPages; int m_nCurrentPage; //&#123;&#123;AFX_MSG(CTabSheet) afx_msg void OnLButtonDown(UINT nFlags, CPoint point); afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar); //&#125;&#125;AFX_MSG DECLARE_MESSAGE_MAP()&#125;;///////////////////////////////////////////////////////////////////////////////&#123;&#123;AFX_INSERT_LOCATION&#125;&#125;// Microsoft Visual C++ will insert additional declarations immediately before the previous line.#endif // !defined(AFX_TABSHEET_H__42EE262D_D15F_46D5_8F26_28FD049E99F4__INCLUDED_) TabSheet.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// TabSheet.cpp : implementation file//#include &quot;afxdialogex.h&quot;//#include &quot;Property5.h&quot;#include &quot;TabSheet.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CTabSheetCTabSheet::CTabSheet()&#123; m_nNumOfPages = 0; m_nCurrentPage = 0;&#125;CTabSheet::~CTabSheet()&#123;&#125;BEGIN_MESSAGE_MAP(CTabSheet, CTabCtrl) //&#123;&#123;AFX_MSG_MAP(CTabSheet) ON_WM_LBUTTONDOWN() ON_WM_HSCROLL() //&#125;&#125;AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CTabSheet message handlersBOOL CTabSheet::AddPage(LPCTSTR title, CDialog *pDialog,UINT ID)&#123; if( MAXPAGE == m_nNumOfPages ) return FALSE; m_nNumOfPages++; m_pPages[m_nNumOfPages-1] = pDialog; m_IDD[m_nNumOfPages-1] = ID; m_Title[m_nNumOfPages-1] = title; return TRUE;&#125;void CTabSheet::SetRect()&#123; CRect tabRect, itemRect; int nX, nY, nXc, nYc; GetClientRect(&amp;tabRect); GetItemRect(0, &amp;itemRect); nX=itemRect.left; nY=itemRect.bottom+1; nXc=tabRect.right-itemRect.left-2; nYc=tabRect.bottom-nY-2; m_pPages[0]-&gt;SetWindowPos(&amp;wndTop, nX, nY, nXc, nYc, SWP_SHOWWINDOW); for( int nCount=1; nCount &lt; m_nNumOfPages; nCount++ ) m_pPages[nCount]-&gt;SetWindowPos(&amp;wndTop, nX, nY, nXc, nYc, SWP_HIDEWINDOW);&#125;void CTabSheet::Show()&#123; int i = 0; for( i=0; i &lt; m_nNumOfPages; i++ ) &#123; m_pPages[i]-&gt;Create( m_IDD[i], this ); if (AfxGetMainWnd()) InsertItem( i, m_Title[i] ); else return; &#125; m_pPages[0]-&gt;ShowWindow(SW_SHOW); for( i=1; i &lt; m_nNumOfPages; i++) m_pPages[i]-&gt;ShowWindow(SW_HIDE); SetRect();&#125;void CTabSheet::OnLButtonDown(UINT nFlags, CPoint point) &#123; CTabCtrl::OnLButtonDown(nFlags, point); if(m_nCurrentPage != GetCurFocus()) &#123; m_pPages[m_nCurrentPage]-&gt;ShowWindow(SW_HIDE); m_nCurrentPage=GetCurFocus(); m_pPages[m_nCurrentPage]-&gt;ShowWindow(SW_SHOW);// m_pPages[m_nCurrentPage]-&gt;SetFocus(); //AfxMessageBox(&quot;бЁжа&quot;); wbm test &#125;&#125;int CTabSheet::SetCurSel(int nItem)&#123; if( nItem &lt; 0 || nItem &gt;= m_nNumOfPages) return -1; int ret = m_nCurrentPage; if(m_nCurrentPage != nItem ) &#123; m_pPages[m_nCurrentPage]-&gt;ShowWindow(SW_HIDE); m_nCurrentPage = nItem; m_pPages[m_nCurrentPage]-&gt;ShowWindow(SW_SHOW);// m_pPages[m_nCurrentPage]-&gt;SetFocus(); CTabCtrl::SetCurSel(nItem); &#125; return ret;&#125;int CTabSheet::GetCurSel()&#123; return CTabCtrl::GetCurSel();&#125;void CTabSheet::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) &#123; // TODO: Add your message handler code here and/or call default CTabCtrl::OnHScroll(nSBCode, nPos, pScrollBar);&#125; Tab Control右键添加变量，变量名称为m_tab，类型为CTabSheet（&#x3D;&#x3D;一点要修改其变量类型&#x3D;&#x3D;） 创建两个标签页，在资源视图Dialog选项中右键插入Dialog，更改其属性，边框（Border）选择None，样式（Style）选择Child。 在标签页中添加类，对应Qt中一个ui对应一个.h和一个.cpp文件 在主窗口中添加标签。AddPage（）方法中第一参数为标题，第二个参数为具体添加的标签页，第三个参数为该标签页对应的ID号 1m_tab.AddPage(TEXT(&quot;页面2&quot;), &amp;dlg2, IDD_DIALOG2); 最后一步调用show（）方法来让添加的标签显示出来。 12//显示m_tab.Show();","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"MFC静态文本控件","slug":"MFC静态文本控件","permalink":"https://junxiansen.cn/tags/MFC%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6/"}]},{"title":"4-MFC基于对话框学习控件(2)","slug":"4-MFC基于对话框学习控件-2","date":"2022-08-15T08:38:22.000Z","updated":"2022-08-18T01:34:05.545Z","comments":true,"path":"4-MFC基于对话框学习控件-2.html","link":"","permalink":"https://junxiansen.cn/4-MFC%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%AD%A6%E4%B9%A0%E6%8E%A7%E4%BB%B6-2.html","excerpt":"","text":"编辑框的使用 1）编辑框控件名称为Edit Control。此控件有一个小bug，当输入文本后按下回车后，窗口会关闭，需要重写OnOK()函数。 – 在&#x3D;&#x3D;类视图&#x3D;&#x3D;中Dlg右键属性，在属性界面选择重写按钮。如图所示 添加ok函数，在函数中注释对应代码。 1234567void CEditContrlDlg::OnOK()&#123; // TODO: 在此添加专用代码和/或调用基类 //CDialogEx::OnOK();&#125; 2）Edit Control控件的属性更改。 ​ mutiline多行，True时编辑框可以编辑多行，False时只能编辑一行。 ​ wantreturn想要返回，True时可以通过回车键来编辑下一行。False时按下回车不能进入下一行。 ​ Auto HScroll和Auto VScroll分别可以让编辑框水平和垂直写东西。 ​ 滚动条有Horizontal Scroll(水平滚动)和Vertial Scroll(垂直滚动)，分别进行上下，左右拉动。 3）GetWindowText()和SetWindowText()获取和设置文本值。 4）退出当前对话框一个有三种方式。 ​ 第一种退出当前的对话框。exit(0); ​ 第二种以确认的方式退出当前的对话框。OnOK(); ​ 第三种以取消的方式退出当前的对话框。OnCancel(); 5）对控件添加变量时还可以选择Value（值），类型可更换，如下图所示。 6）该控件所关联的值就是m_text，类型为CString，可以直接修改其值。 m_text = &quot;哈哈&quot;; 7）UpdateData(TRUE),是将控件的内容同步到变量中，比如获取当前编辑框内容按钮代码步骤,先将控件的内容同步到m_text变量中，然后MessageBox获取内容。 12345678void CEditContrlDlg::OnBnClickedButton()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); MessageBox(m_text);&#125; 8）UpdateData(FALSE);先设置变量内容，然后将变量同步到控件中。比如设置当前编辑框内容按钮代码步骤，先定义变量m_text,然后同步到控件中。 123456void CEditContrlDlg::OnBnClickedButton()&#123; // TODO: 在此添加控件通知处理程序代码 m_text = &quot;哈哈&quot;; UpdateData(FALSE);&#125;","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"MFC编辑框控件","slug":"MFC编辑框控件","permalink":"https://junxiansen.cn/tags/MFC%E7%BC%96%E8%BE%91%E6%A1%86%E6%8E%A7%E4%BB%B6/"}]},{"title":"4-MFC基于对话框学习控件(1)","slug":"4-MFC基于对话框学习控件-1","date":"2022-08-15T05:35:25.000Z","updated":"2022-08-15T07:22:07.531Z","comments":true,"path":"4-MFC基于对话框学习控件-1.html","link":"","permalink":"https://junxiansen.cn/4-MFC%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%AD%A6%E4%B9%A0%E6%8E%A7%E4%BB%B6-1.html","excerpt":"","text":"基于对话框学习控件 对话框分为模态和非模态 按钮可以点在captain修改内容或者点击一次输入内容 触发事件有三种方法，右侧属性中的闪电图标，右侧按钮添加事件处理程序，双击按钮 插入窗口（添加ui），在窗口中右键添加类，类似于Qt中一个.h,一个.c对应一个ui界面 模态窗口创建，先定义对象，然后使用DoModal()函数 非模态窗口创建，先定义个全局的对象，在初始化函数创建窗口，通过按钮点击实现显示出来。 静态文本控件 添加变量，以STATIC结尾的ID是不可以添加变量的，需要修改ID 设置内容 setWindowTextW()，按钮同样使用 获取内容 getWindowTextW()，按钮同样适用 利用静态文本显示图片，图片类型必须是bmp的格式 设置图片宏，写在初始化代码中，最后静态控件设置bitmap 禁用按钮，EnableWindow(FALSE) 在资源视图对控件添加变量实现绑定，添加的变量在DoDataExchange()函数中可以看到，将Static Text2控件添加变量，变量值为m_label。 1234567void CMy2CStaticTextDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Control(pDX, IDC_TEXT2, m_label);&#125; 根据实际Static Text控件的大小，将图片平铺控件中。 123456789101112//设置静态控件窗口风格为位图居中显示m_label.ModifyStyle(0xf, SS_BITMAP | SS_CENTERIMAGE); CRect rect;m_label.GetWindowRect(rect); //通过路径获取bitmap句柄#define HBMP(filepath,width,height) (HBITMAP)LoadImage(AfxGetInstanceHandle(),filepath,IMAGE_BITMAP,width,height,LR_LOADFROMFILE|LR_CREATEDIBSECTION)//静态控件设置bitmapm_label.SetBitmap(HBMP(TEXT(&quot;./1.bmp&quot;), rect.Width(),rect.Height()));","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"MFC静态文本控件","slug":"MFC静态文本控件","permalink":"https://junxiansen.cn/tags/MFC%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6/"}]},{"title":"1-Ubuntu桌面基础操作","slug":"1-Ubuntu桌面基础操作","date":"2022-08-11T14:22:50.000Z","updated":"2022-08-15T14:32:30.232Z","comments":true,"path":"1-Ubuntu桌面基础操作.html","link":"","permalink":"https://junxiansen.cn/1-Ubuntu%E6%A1%8C%E9%9D%A2%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"Ubuntu桌面简单操作根目录下面的bin和sbin，存放必需的app。 usr目录的意思是Unix Software Resource不是用户的意思，usr里存放可分享不可变动的数据。usr目录下的bin和sbin存放的是非必需要的app。 var针对可变动的文件，包括缓存（cache）、log文件等。 proc用来挂载虚拟的proc文件系统，可以查看各种的进程信息。 sys用来挂载虚拟sys文件系统，可以查看系统信息，比如设备信息。 proc和sys用来挂载虚拟文件系统。 Linux入门命令 pwd 显示当前所在的目录 &#x3D;&#x3D;p&#x3D;&#x3D;rint &#x3D;&#x3D;w&#x3D;&#x3D;ork &#x3D;&#x3D;d&#x3D;&#x3D;irectory ls 显示当前目录下的文件 cd 切换路径 &#x3D;&#x3D;c&#x3D;&#x3D;hange &#x3D;&#x3D;d&#x3D;&#x3D;irectory cd .. 返回上一级路径 mkdir 新建目录 rmdir 删除目录 touch 新建文件 cp 复制文件 rm 删除文件 cat 将文件内容显示到终端 clear 清楚屏幕显示的内容 shell命令解释器说明shell是一个应用程序，可以通过键盘，串口给它发送命令，回车后执行命令。 在终端输入字符串后，shell会解析字符串，字符串用空格分为好几部分 第一部分就是程序名、命令名，其他部分是参数，例如ls -l，ls为程序，-l为参数。 shell会去哪里寻找程序呢？去PATH环境变量所指示的位置寻找 shell找到程序后，启动该程序传入参数shell还有其他功能，可以编写脚本等。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://junxiansen.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://junxiansen.cn/tags/Linux/"},{"name":"Ubuntu桌面","slug":"Ubuntu桌面","permalink":"https://junxiansen.cn/tags/Ubuntu%E6%A1%8C%E9%9D%A2/"}]},{"title":"3-MFC消息映射","slug":"3-MFC消息映射","date":"2022-08-11T14:14:55.000Z","updated":"2022-08-11T14:15:46.277Z","comments":true,"path":"3-MFC消息映射.html","link":"","permalink":"https://junxiansen.cn/3-MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84.html","excerpt":"","text":"MFC消息映射机制 消息映射是一个将消息和成员函数相互关联的表。 声明宏，写到.h中 分解宏，写到.cpp中 找消息宏，写到分解宏中间 把函数原型声明写到.h中 函数的实现写到.cpp中 例如鼠标、键盘、绘图消息","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"MFC消息映射","slug":"MFC消息映射","permalink":"https://junxiansen.cn/tags/MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84/"}]},{"title":"2-MFC窗口创建","slug":"2-MFC窗口创建","date":"2022-08-11T14:10:51.000Z","updated":"2022-08-11T14:12:58.770Z","comments":true,"path":"2-MFC窗口创建.html","link":"","permalink":"https://junxiansen.cn/2-MFC%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA.html","excerpt":"","text":"MFC是以C++类的形式封装了Windows API，编写MFC程序需要包含#include &lt;afxwin.h&gt;头文件 自定义类继承 CWinApp应用程序类，MyApp app 应用程序对象，应用程序对象有且仅有一个 程序入口 InitInstance 入口里创建窗口 窗口类MyFrame继承CFrameWind 创建窗口对象 显示和更新 m_pMainWnd &#x3D; frame &#x2F;&#x2F;保存指向应用程序的主窗口的指针 returen TURE 对项目更改配置 1234567891011121314#include &lt;afxwin.h&gt;class Myapp :public CWinApp&#123;public: virtual BOOL InitInstance();&#125;;class MyFrame:public CFrameWnd&#123;public: MyFrame();&#125;; 123456789101112131415161718192021#include &quot;MFC.h&quot;Myapp app;BOOL Myapp::InitInstance()&#123; MyFrame* frame = new MyFrame; frame-&gt;ShowWindow(SW_SHOWNORMAL); frame-&gt;UpdateWindow(); m_pMainWnd = frame; return TRUE;&#125;MyFrame::MyFrame() &#123; Create(NULL, TEXT(&quot;WINDOWS&quot;));&#125; CWinAPP继承于CWinThread，CWinThread数据成员有m_PMainWind，通过指针绑定自定义的主窗口，进行操作。","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"MFC窗口创建","slug":"MFC窗口创建","permalink":"https://junxiansen.cn/tags/MFC%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA/"}]},{"title":"1-底层WinMain入口函数","slug":"1-底层WinMain入口函数","date":"2022-08-11T13:57:20.000Z","updated":"2022-08-11T14:03:14.001Z","comments":true,"path":"1-底层WinMain入口函数.html","link":"","permalink":"https://junxiansen.cn/1-%E5%BA%95%E5%B1%82WinMain%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0.html","excerpt":"","text":"SDK:软件开发集成包 API：应用程序编程接口 windows窗口可分为客户区和非客户区 句柄：在windows程序中，有各种各样的资源（窗口、图标、光标等），系统在创建这些资源时会为他们分配内存，并返回这些资源的标识号，这些标识号称为句柄。 window程序步骤分为 1）WinMain函数的定义 2）创建一个窗口 3）进行消息循环 4）编写窗口过程函数 123456789101112131415161718192021底层窗口实现，WinMain入口函数`//WINAPI 代表__stdcall参数传递顺序从右到左依次入栈，并且在函数返回前，清空堆栈`int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,nShowCmd)`&#123;//1、设计窗口`//2、注册窗口`//3、创建窗口`//4、显示与更新窗口`//5、设计消息循环`//6、处理消息（窗口过程）`&#125;","categories":[{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"WinMain函数","slug":"WinMain函数","permalink":"https://junxiansen.cn/tags/WinMain%E5%87%BD%E6%95%B0/"}]},{"title":"Markdown高级语法","slug":"markdown-advance-syntax","date":"2022-05-08T09:04:21.000Z","updated":"2022-05-08T09:04:21.000Z","comments":true,"path":"markdown-advance-syntax.html","link":"","permalink":"https://junxiansen.cn/markdown-advance-syntax.html","excerpt":"只有少数编辑器支持，或者需要安装相应的扩展渲染，使用前请先预览确认。","text":"只有少数编辑器支持，或者需要安装相应的扩展渲染，使用前请先预览确认。 定义列表1234Term 1Term 2: Definition A: Definition B 会被编译成 123456&lt;dl&gt;&lt;dd&gt;Term 1&lt;/dd&gt;&lt;dd&gt;Term 2&lt;/dd&gt;&lt;dt&gt;Definition A&lt;dt&gt;&lt;dt&gt;Definition A&lt;dt&gt;&lt;/dl&gt; 目录通过[TOC]标记来插入目录。 在编辑器不支持[TOC]标记的情况下可以使用添加id的方法构建目录。 123456## Directory* [1.Content one](#chapter1)* [2.Content two](#chapter2)## &lt;span id=&quot;chapter1&quot;&gt;1.Content one&lt;/span&gt;## &lt;span id=&quot;chapter2&quot;&gt;2.Content two&lt;/span&gt; TeX公式内联的TeX公式使用一个美元符号标记。 1$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 会被编译成内联（行内）公式：$\\Gamma(n) &#x3D; (n-1)!\\quad\\forall n\\in\\mathbb N$ TeX公式块用独占一行的两个美元符号来标记。 1$$\\left \\lbrace \\sum_&#123;i=0&#125;^n i^3 = \\frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \\right \\rbrace$$ 会被编译成 $$\\left \\lbrace \\sum_{i&#x3D;0}^n i^3 &#x3D; \\frac{(n^2+n)(n+6)}{9} \\right \\rbrace$$ 如果你的编辑器不支持这个功能，可以手动解决。首先引入mathjax脚本： 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt; 之后，在需要插入公式的地方使用 &lt;script&gt; 标签包裹公式： 12345&lt;script type=&quot;math/tex&quot;&gt;\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;\\Gamma(z) = \\int_0^\\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\\,.&lt;/script&gt; 以上公式展示效果，在实际显示过程中，根据网络加载速度不同会有不同的解析展示速度，TeX的语法参考请见这里。 UML图语法为在代码块开始行后面加入语法声明，如 ```mermaid ，然后可以像这样来画uml时序图： sequenceDiagram Alice->>Bob: Hello Bob,how are you? Note right of Bob: Bob thinks Bob-->>Alice: I am fine thanks! and U? Note left of Alice: SB 其MarkDown代码如下： 1234567\\`\\`\\`mermaidsequenceDiagram Alice-&gt;&gt;Bob: Hello Bob,how are you? Note right of Bob: Bob thinks Bob--&gt;&gt;Alice: I am fine thanks! and U? Note left of Alice: SB\\`\\`\\` #代码块标识会被解析，实际上写代码块时不用添加转义符“\\” 时序图的语法请见 这里 或 这里。 uml流程图： graph LR; A-->B & C-->D; 其实现代码如下： 1234\\`\\`\\`mermaidgraph LR; A--&gt;B &amp; C--&gt;D;\\`\\`\\` 流程图的语法请见 这里， 更复杂点的flowchart可以看 这里 。 参考文档 MarkDown文档中如何画出流程图 https://github.com/wizardforcel/markdown-simple-world http://stevenshi.me/2017/06/26/hexo-insert-formula/ https://blog.csdn.net/u013282174/article/details/80666123 https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html https://mermaidjs.github.io/","categories":[{"name":"学编程","slug":"学编程","permalink":"https://junxiansen.cn/categories/%E5%AD%A6%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"混技能","slug":"混技能","permalink":"https://junxiansen.cn/tags/%E6%B7%B7%E6%8A%80%E8%83%BD/"}]},{"title":"学术简历样本","slug":"academia-example","date":"2022-02-21T18:02:02.000Z","updated":"2023-03-29T14:34:31.663Z","comments":true,"path":"academia-example.html","link":"","permalink":"https://junxiansen.cn/academia-example.html","excerpt":"","text":"这是个学术简历示例，内容源文件：source/_posts/academia-example.md 如果本页排序在站内靠后，该页内容不会在 Academia 主题首页显示，不知道为何，如果遇到不显示的问题，删除其他内容或者将本页排序调整到靠前几页 About meThis is a simple page for academic website based on Hexo. It just provides a theme frame and all depends on your markdown posts’ styles. This is the index page which organized with the posts you write in markdown files. News 2020-04-23: ver 1.2.0 publish, support pjax. 2020 February, Join in Test University. A new theme for academic page is published. Publications Einstein, Albert, Boris Podolsky, and Nathan Rosen. “Can quantum-mechanical description of physical reality be considered complete?.” Physical review 47.10 (1935): 777. Einstein, Albert, Boris Podolsky, and Nathan Rosen. “Can quantum-mechanical description of physical reality be considered complete?.” Physical review 47.10 (1935): 777. Add more informations in your posts… IntroductionThis is a light &amp; simple &amp; responsive theme for academic websites on Hexo, crafted from academicpages on Jekyll. Thanks a lot. The theme adopts only post and page in Hexo to show your informations. For an academic page, it’s important to be simple and obvious. Example page: phosphorw.github.io PreparationSome skills you need: Publish a Hexo blog: Learn more Git Markdown: Learn more Deploy a server (Optional) Balabala… InstallationThe simplest way to install is to clone the entire repository: 1git clone https://github.com/PhosphorW/hexo-theme-academia.git themes/Academia Some required renderers: 1npm install hexo-renderer-pug hexo-renderer-stylus --save Set theme in hexo work folder’s _config.yml 1theme: Academia Create your academic pageOnly post and page are supported in this theme. 1hexo n post &quot;any title&quot; or 1hexo n page &quot;any title&quot; Important: Add academia: true in front_matter filed in post .md. Only post with academia: true front_matter will be shown on home (index) page. You can write your informations in either one post or some posts with this method. The front_matter doesn’t works in page. The pages are standalone with its markdown content. Theme ConfigurtionAll of below options can be config in theme folder _config.yml Top Menu: in-page anchor, new page links or any links you like Side Bar: Support avatar, social links, extra social links (optional), CV_download_link Box-shadow mode (optional) All icons in page is supported with font-awesome-5 (font-awesome-4) fontawesome-4 is not used since v1.2.1. If you want to update manually, first change CDN stylesheet to fa5. Then change your previous icon class fa to fas or fas. If you need rss feed, use hexo plugin: hexo-generator-feed Update ThemeThis theme supports data files smooth update. Copy _config.yml in theme folder to site folder /source/_data/theme.yml, if there is no _data folder, create it. Then you can modify your theme configuration in the mentioned theme.yml. If there is any update, just pull the new branch and your configurations won’t be merged. Note: When use data files to config theme, you must restart hexo server after any modifictions. hexo server again. Sometimes there will be changes in theme _config.yml, please refer to release page for more details before update. Document中文文档：Hexo-Theme-Academia 说明文档","categories":[],"tags":[{"name":"Example","slug":"Example","permalink":"https://junxiansen.cn/tags/Example/"}]}],"categories":[{"name":"uCOS-III","slug":"uCOS-III","permalink":"https://junxiansen.cn/categories/uCOS-III/"},{"name":"数据结构","slug":"数据结构","permalink":"https://junxiansen.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"QT和MFC","slug":"QT和MFC","permalink":"https://junxiansen.cn/categories/QT%E5%92%8CMFC/"},{"name":"Linux","slug":"Linux","permalink":"https://junxiansen.cn/categories/Linux/"},{"name":"学编程","slug":"学编程","permalink":"https://junxiansen.cn/categories/%E5%AD%A6%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://junxiansen.cn/tags/Example/"},{"name":"时钟节拍","slug":"时钟节拍","permalink":"https://junxiansen.cn/tags/%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D/"},{"name":"创建任务","slug":"创建任务","permalink":"https://junxiansen.cn/tags/%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1/"},{"name":"栈","slug":"栈","permalink":"https://junxiansen.cn/tags/%E6%A0%88/"},{"name":"栈的原理","slug":"栈的原理","permalink":"https://junxiansen.cn/tags/%E6%A0%88%E7%9A%84%E5%8E%9F%E7%90%86/"},{"name":"背景","slug":"背景","permalink":"https://junxiansen.cn/tags/%E8%83%8C%E6%99%AF/"},{"name":"uCOS","slug":"uCOS","permalink":"https://junxiansen.cn/tags/uCOS/"},{"name":"MFC","slug":"MFC","permalink":"https://junxiansen.cn/tags/MFC/"},{"name":"字符集","slug":"字符集","permalink":"https://junxiansen.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"MFC静态文本控件","slug":"MFC静态文本控件","permalink":"https://junxiansen.cn/tags/MFC%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6/"},{"name":"MFC编辑框控件","slug":"MFC编辑框控件","permalink":"https://junxiansen.cn/tags/MFC%E7%BC%96%E8%BE%91%E6%A1%86%E6%8E%A7%E4%BB%B6/"},{"name":"Linux","slug":"Linux","permalink":"https://junxiansen.cn/tags/Linux/"},{"name":"Ubuntu桌面","slug":"Ubuntu桌面","permalink":"https://junxiansen.cn/tags/Ubuntu%E6%A1%8C%E9%9D%A2/"},{"name":"MFC消息映射","slug":"MFC消息映射","permalink":"https://junxiansen.cn/tags/MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84/"},{"name":"MFC窗口创建","slug":"MFC窗口创建","permalink":"https://junxiansen.cn/tags/MFC%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA/"},{"name":"WinMain函数","slug":"WinMain函数","permalink":"https://junxiansen.cn/tags/WinMain%E5%87%BD%E6%95%B0/"},{"name":"混技能","slug":"混技能","permalink":"https://junxiansen.cn/tags/%E6%B7%B7%E6%8A%80%E8%83%BD/"}]}